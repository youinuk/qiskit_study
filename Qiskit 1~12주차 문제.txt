# Qiskit 스터디 1~12주차 문제

## Week 1: 기초 복습 및 심화
### 문제 1: "2큐비트 가산기"
```python
# 두 개의 단일 비트를 더하는 양자 가산기를 구현하세요.
# 입력: |a⟩|b⟩|0⟩ (a,b는 각각 0 또는 1)
# 출력: |a⟩|b⟩|s⟩ (s는 a+b의 결과)

# 요구사항:
# 1. 덧셈 결과 s와 캐리 비트 c를 모두 출력
# 2. 다음 입력들에 대해 테스트하고 결과 확인:
#    - |0⟩|0⟩|0⟩ → |0⟩|0⟩|0⟩
#    - |0⟩|1⟩|0⟩ → |0⟩|1⟩|1⟩
#    - |1⟩|1⟩|0⟩ → |1⟩|1⟩|0⟩ (캐리 비트 1)
# 3. 회로도와 측정 결과를 히스토그램으로 표시
```

### 문제 2: "GHZ vs W 상태"
```python
# 3큐비트 시스템에서 GHZ 상태와 W 상태를 생성하고 비교하세요.
# GHZ 상태: |GHZ⟩ = (|000⟩ + |111⟩)/√2
# W 상태: |W⟩ = (|001⟩ + |010⟩ + |100⟩)/√3

# 요구사항:
# 1. 두 상태를 각각 생성하는 회로 구현
# 2. 각 상태에 대해 다음 측정 수행:
#    - 모든 큐비트를 Z-기저로 측정
#    - 모든 큐비트를 X-기저로 측정
# 3. 각 상태의 밀도 행렬을 구하고 시각화
# 4. 한 큐비트를 잃어버렸을 때 두 상태의 차이점 분석
```

### 문제 3: "양자 상태 전송"
```python
# A가 B에게 임의의 2큐비트 상태를 다음 과정으로 전송하세요:
# |ψ⟩ = α|00⟩ + β|01⟩ + γ|10⟩ + δ|11⟩

# 요구사항:
# 1. 다음 세 가지 특정 상태에 대해 전송 구현:
#    - |ψ1⟩ = (|00⟩ + |11⟩)/√2
#    - |ψ2⟩ = (|01⟩ + |10⟩)/√2
#    - |ψ3⟩ = (|00⟩ + |01⟩ + |10⟩ + |11⟩)/2
# 2. 각 전송에 대해 상태 토모그래피 수행
# 3. 충실도(fidelity) 계산 및 85% 이상 달성
```

## Week 2: 양자 알고리즘 기초
### 문제 1: "변형된 Deutsch 문제"
```python
# 다음 함수들이 상수인지 균형인지 판별하세요:
# f1(x) = x AND 1
# f2(x) = x XOR 1
# f3(x) = NOT(x OR 1)

# 요구사항:
# 1. 각 함수에 대한 양자 오라클 구현
# 2. 단 한 번의 함수 호출로 판별 수행
# 3. 각 함수에 대해 다음 검증:
#    - 고전적 진리표 작성
#    - 양자 회로 구현
#    - 결과의 확률 분포 시각화
```

### 문제 2: "2비트 QFT 계산기"
```python
# 2큐비트 양자 푸리에 변환 계산기를 구현하세요.

# 요구사항:
# 1. 다음 입력 상태들에 대해 QFT 수행:
#    - |00⟩
#    - |10⟩
#    - (|00⟩ + |10⟩)/√2
# 2. 각 경우에 대해:
#    - 이론적 결과값 계산
#    - 실제 구현 결과와 비교
#    - 상대 위상 관계 분석
# 3. 역변환(IQFT)을 적용하여 원래 상태 복원 검증
```

## Week 3: 양자 오류 보정
### 문제 1: "비트 플립 오류 탐지"
```python
# 3큐비트 비트 플립 코드를 구현하여 다음 시나리오 해결:

# 요구사항:
# 1. 다음 상태들을 인코딩:
#    - |0⟩ → |000⟩
#    - |1⟩ → |111⟩
#    - |+⟩ → (|000⟩ + |111⟩)/√2
# 2. 각각의 경우에 대해:
#    - 첫 번째 큐비트에 X 오류 적용
#    - 두 번째 큐비트에 X 오류 적용
#    - 세 번째 큐비트에 X 오류 적용
# 3. 오류 신드롬 측정 및 교정 수행
# 4. 각 단계의 상태 충실도 계산
```

### 문제 2: "위상 오류 보정"
```python
# 3큐비트 위상 플립 코드로 다음 실험 수행:

# 요구사항:
# 1. 다음 상태를 인코딩:
#    |+⟩ = (|0⟩ + |1⟩)/√2
# 2. 다음 오류들을 시뮬레이션:
#    - Z1: 첫 번째 큐비트에 위상 플립
#    - Z2: 두 번째 큐비트에 위상 플립
#    - Z3: 세 번째 큐비트에 위상 플립
# 3. 각 경우에 대해:
#    - 오류 검출 회로 구현
#    - 오류 위치 특정
#    - 상태 복원 수행
# 4. 복원된 상태와 원래 상태 간의 충실도 측정
```

## Week 4: Deutsch-Jozsa 심화
### 문제 1: "3비트 DJ 알고리즘"
```python
# 3큐비트 Deutsch-Jozsa 알고리즘으로 다음 함수들 분석:

# 요구사항:
# 1. 다음 함수들에 대한 오라클 구현:
#    f1(x) = 1 (모든 x에 대해)
#    f2(x) = x1 XOR x2 XOR x3
#    f3(x) = x1 AND x2
# 2. 각 함수에 대해:
#    - 고전적 방법으로 필요한 질의 횟수 계산
#    - 양자 회로 구현
#    - 한 번의 질의로 함수 특성 판별
# 3. 측정 결과를 히스토그램으로 시각화
```

### 문제 2: "DJ 알고리즘 변형"
```python
# Deutsch-Jozsa 알고리즘을 수정하여 다음 문제 해결:

# 요구사항:
# 1. 함수가 다음 중 어느 경우인지 판별:
#    - 모든 입력에 대해 0을 출력
#    - 모든 입력에 대해 1을 출력
#    - 정확히 절반의 입력에 대해 1을 출력
# 2. 다음 테스트 함수들 구현:
#    - f1(x) = 0
#    - f2(x) = 1
#    - f3(x) = x1 (첫 번째 비트값)
# 3. 각 함수의 특성을 한 번의 양자 질의로 판별
```

## Week 5: Grover 알고리즘 기초
### 문제 1: "2큐비트 Grover 검색"
```python
# 2큐비트 시스템에서 Grover 알고리즘 구현:

# 요구사항:
# 1. 다음 상태들을 찾는 오라클 구현:
#    - |11⟩ 상태 검색
#    - |10⟩ 상태 검색
#    - (|00⟩ 또는 |11⟩) 상태 검색
# 2. 각 경우에 대해:
#    - 이론적 최적 반복 횟수 계산
#    - 실제 구현 및 측정
#    - 성공 확률 계산
# 3. 반복 횟수에 따른 성공 확률 변화 그래프 작성
```

### 문제 2: "데이터베이스 검색"
```python
# 4개 항목 데이터베이스에서 특정 항목 검색:

# 요구사항:
# 1. 다음 데이터베이스 구현:
#    - 항목: 00, 01, 10, 11
#    - 각 항목에 대한 표시 함수 f(x) 구현
# 2. 다음 검색 수행:
#    - f(x) = 1 인 단일 항목 검색
#    - f(x) = 1 인 두 개 항목 검색
# 3. 각 경우의 최적 반복 횟수 결정
# 4. 고전적 검색과 속도 비교 분석
```

## Week 6: QAOA 입문
### 문제 1: "2x2 MaxCut"
```python
# 4개 노드를 가진 그래프에서 MaxCut 문제 해결:

# 요구사항:
# 1. 다음 그래프에 대한 MaxCut 구현:
#    - 노드: A(00), B(01), C(10), D(11)
#    - 엣지: (A-B), (B-C), (C-D), (D-A), (A-C)
# 2. QAOA 회로 구현:
#    - Mixer 해밀토니안 구성
#    - Cost 해밀토니안 구성
#    - p=1, p=2 각각의 경우 구현
# 3. 다음 분석 수행:
#    - 최적의 β, γ 파라미터 탐색
#    - 고전적 최적해와 비교
#    - 회로 깊이에 따른 정확도 분석
```

### 문제 2: "QAOA 파라미터 최적화"
```python
# MaxCut QAOA의 파라미터 최적화 실험:

# 요구사항:
# 1. 3개 노드 삼각형 그래프에 대해:
#    - 완전한 cost function 구현
#    - 1단계(p=1) QAOA 회로 설계
# 2. 다음 최적화 방법 비교:
#    - Grid Search (β: 0~π, γ: 0~2π)
#    - COBYLA 최적화
#    - Gradient Descent 최적화
# 3. 각 방법에 대해:
#    - 수렴 속도 비교
#    - 최종 해의 품질 평가
#    - 계산 비용 분석
```

## Week 7: VQE 기초
### 문제 1: "H2 분자 시뮬레이션"
```python
# 수소 분자(H2)의 기저 상태 에너지 계산:

# 요구사항:
# 1. 해밀토니안 구성:
#    - Bravyi-Kitaev 변환 사용
#    - Pauli 연산자 텀으로 표현
# 2. Ansatz 회로 구현:
#    - Hardware Efficient Ansatz
#    - RY + CZ 게이트 조합
#    - 2개 및 4개 파라미터 버전
# 3. 다음 결과 분석:
#    - 기저 상태 에너지 곡선 그리기
#    - 정확한 값과의 오차 계산
#    - 파라미터 수에 따른 정확도 비교
```

### 문제 2: "VQE 개선 실험"
```python
# 다양한 VQE 최적화 전략 비교:

# 요구사항:
# 1. 2큐비트 시스템에서 다음 해밀토니안 최소화:
#    H = X⊗X + Z⊗Z
# 2. 다음 세 가지 Ansatz 구현 및 비교:
#    - 기본 RY + CNOT
#    - 전체 엔탱글링 레이어
#    - 커스텀 Ansatz
# 3. 각 경우에 대해:
#    - 수렴까지 필요한 반복 횟수
#    - 최종 에너지 정확도
#    - 노이즈에 대한 강건성
# 4. 측정 횟수 감소 전략 구현
```

## Week 8: 양자 기계학습
### 문제 1: "양자 데이터 인코딩"
```python
# 2차원 데이터의 양자 상태 인코딩 비교:

# 요구사항:
# 1. 다음 데이터셋 준비:
#    - 2차원 평면상의 4개 점
#    - 두 클래스로 분류된 데이터
# 2. 세 가지 인코딩 방식 구현:
#    - Angle 인코딩
#    - Amplitude 인코딩
#    - Basis 인코딩
# 3. 각 인코딩에 대해:
#    - 회로 깊이 비교
#    - 필요한 큐비트 수 분석
#    - 재구성 충실도 계산
```

### 문제 2: "QSVM 분류기"
```python
# 양자 커널을 사용한 SVM 분류기 구현:

# 요구사항:
# 1. 간단한 이진 분류 문제 설정:
#    - XOR 데이터셋 생성
#    - 8개의 훈련 데이터 포인트
# 2. 양자 커널 구현:
#    - ZZ-특성맵 기반 커널
#    - 가변 깊이 회로 기반 커널
# 3. 성능 평가:
#    - 교차 검증 정확도 계산
#    - 고전적 RBF 커널과 비교
#    - 노이즈의 영향 분석
```

## Week 9: 양자 위상 추정
### 문제 1: "단일 큐비트 위상 추정"
```python
# 단일 큐비트 연산자의 위상 추정:

# 요구사항:
# 1. 다음 연산자들의 위상 추정:
#    - S 게이트 (π/2 위상)
#    - T 게이트 (π/4 위상)
#    - Rz(θ) (임의 위상)
# 2. 각 경우에 대해:
#    - 3비트 정밀도로 구현
#    - QFT 기반 회로 구성
#    - 반복 측정으로 정확도 향상
# 3. 정밀도와 성공 확률 관계 분석
```

### 문제 2: "제어 유니터리 위상"
```python
# 2큐비트 제어 연산자의 위상 추정:

# 요구사항:
# 1. 다음 제어 연산자 구현:
#    - Controlled-S
#    - Controlled-T
#    - Controlled-Rz(θ)
# 2. 각 연산자에 대해:
#    - 4비트 정밀도 위상 추정
#    - 에러 보정 적용
#    - 위상 킥백 효과 분석
# 3. 실제 디바이스에서의 구현 최적화
```

## Week 10: 양자 암호
### 문제 1: "BB84 프로토콜"
```python
# BB84 양자 키 분배 프로토콜 구현:

# 요구사항:
# 1. 다음 단계 구현:
#    - 8큐비트 무작위 비트열 생성
#    - 무작위 기저 선택(X 또는 Z)
#    - 상태 준비 및 측정
# 2. Eve의 도청 시나리오 구현:
#    - 중간자 공격 시뮬레이션
#    - 도청 탐지 확률 계산
# 3. 다음 분석 수행:
#    - QBER (Quantum Bit Error Rate) 계산
#    - 최종 키 생성률 측정
#    - 보안성 평가
```

### 문제 2: "양자 난수 생성"
```python
# 진정한 양자 난수 생성기 구현:

# 요구사항:
# 1. 세 가지 방식으로 구현:
#    - Hadamard 기반 단순 QRNG
#    - 얽힘 기반 QRNG
#    - QFT 기반 QRNG
# 2. 각 방식에 대해:
#    - 100비트 시퀀스 생성
#    - 통계적 검정 수행
#    - 편향성 분석
# 3. NIST 무작위성 테스트 수행
```

## Week 11: 양자 게임 이론
### 문제 1: "양자 동전 뒤집기"
```python
# 양자 동전 뒤집기 게임 구현:

# 요구사항:
# 1. 게임 규칙 구현:
#    - 초기 상태 |0⟩ 준비
#    - 플레이어 A의 전략 집합 (I, X, H, HS)
#    - 플레이어 B의 전략 집합 (I, X, H, HS)
# 2. 다음 분석 수행:
#    - 모든 전략 조합의 페이오프 행렬
#    - 내쉬 균형점 찾기
#    - 고전적 전략과 비교
# 3. 최적 양자 전략 도출
```

### 문제 2: "양자 죄수의 딜레마"
```python
# 양자 죄수의 딜레마 게임 구현:

# 요구사항:
# 1. 다음 전략 구현:
#    - 고전적 협력/배신
#    - 양자 얽힘 기반 전략
#    - Eisert-Wilkens-Lewenstein 전략
# 2. 각 전략 쌍에 대해:
#    - 기대 보상 계산
#    - 균형점 분석
#    - 사회적 최적점과 비교
# 3. 노이즈의 영향 분석
```

## Week 12: 최종 프로젝트
### 프로젝트 옵션 1: "양자 화학 시뮬레이터"
```python
# 작은 분자의 에너지 준위 계산:

# 요구사항:
# 1. 다음 분자 중 선택:
#    - H2O (물 분자)
#    - NH3 (암모니아)
#    - CH4 (메탄)
# 2. 구현 사항:
#    - 해밀토니안 매핑
#    - VQE 알고리즘 최적화
#    - 들뜬 상태 계산
# 3. 결과 분석:
#    - 에너지 스펙트럼
#    - 실험값과 비교
#    - 리소스 요구사항 분석
```

### 프로젝트 옵션 2: "양자 금융 시뮬레이터"
```python
# 포트폴리오 최적화 알고리즘 구현:

# 요구사항:
# 1. 문제 설정:
#    - 4-8개 자산 선택
#    - 수익률과 리스크 정의
#    - 제약 조건 설정
# 2. 구현 방법:
#    - QAOA 기반 최적화
#    - VQE 기반 최적화
#    - 하이브리드 알고리즘
# 3. 평가 기준:
#    - Sharpe 비율 최적화
#    - 실행 시간 분석
#    - 고전적 방법과 비교
```

### 프로젝트 옵션 3: "양자 기계학습 시스템"
```python
# 실제 데이터셋에 대한 양자 ML 시스템:

# 요구사항:
# 1. 데이터 준비:
#    - MNIST 부분집합 또는
#    - Iris 데이터셋 또는
#    - 사용자 정의 데이터셋
# 2. 구현 사항:
#    - 데이터 인코딩 최적화
#    - 양자 회로 설계
#    - 하이브리드 학습 알고리즘
# 3. 성능 평가:
#    - 정확도 및 일반화
#    - 실행 시간 분석
#    - 리소스 사용량 평가
```

각 주차의 문제들은 다음을 포함합니다:
- 명확한 입력과 출력 명세
- 구체적인 구현 단계
- 검증 가능한 성능 메트릭
- 심화 학습을 위한 추가 과제
